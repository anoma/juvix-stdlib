module Test;

open import Stdlib.Prelude hiding {+};

import Stdlib.Data.Nat.Ord as Nat;
import Stdlib.Data.Nat as Nat;
import Stdlib.Data.Ord as Ord;

open import Stdlib.Data.Int.Ord;
open import Stdlib.Data.Int;
open import Data.List;
open import Data.String;
open import Data.Int;

import Test.QuickCheckTest as QC;

prop-reverseDoesNotChangeLength : List Int -> Bool;
prop-reverseDoesNotChangeLength xs :=
  length (reverse xs) Nat.== length xs;

prop-reverseReverseIsIdentity : List Int -> Bool;
prop-reverseReverseIsIdentity xs :=
  eqListInt xs (reverse (reverse xs));

prop-tailLengthOneLess : List Int -> Bool;
prop-tailLengthOneLess xs :=
  null xs
    || ofNat (length (tail xs)) == intSubNat (length xs) 1;

prop-splitAtRecombine : Nat -> List Int -> Bool;
prop-splitAtRecombine n xs :=
  case splitAt n xs
    | lhs, rhs := eqListInt xs (lhs ++ rhs);

prop-mergeSumLengths : List Int -> List Int -> Bool;
prop-mergeSumLengths xs ys :=
  length xs Nat.+ length ys
    Nat.== length (merge compare xs ys);

prop-partition : List Int -> (Int -> Bool) -> Bool;
prop-partition xs p :=
  case partition p xs
    | lhs, rhs :=
      all p lhs
        && not (any p rhs)
        && eqListInt (sortInt xs) (sortInt (lhs ++ rhs));

prop-distributive : Int -> Int -> (Int -> Int) -> Bool;
prop-distributive a b f := f (a + b) == f a + f b;

prop-add-sub : Int -> Int -> Bool;
prop-add-sub a b := a == a + b - b;

prop-add-sub-bad : Int -> Int -> Bool;
prop-add-sub-bad a b := a == 2;

prop-gcd-bad : Int -> Int -> Bool;
prop-gcd-bad a b := gcd a b > 1;

prop-equal-compare-to-eq : Nat -> Bool;
prop-equal-compare-to-eq a := Ord.isEQ (Nat.compare a a);

prop-sort : (List Int -> List Int) -> List Int -> Bool;
prop-sort sort xs :=
   let
     sorted : List Int := sort xs;
     isSorted : List Int -> Bool;
     isSorted nil := true;
     isSorted (_ :: nil) := true;
     isSorted (x :: y :: xs) := (x <= y) && isSorted (y :: xs);
   in
     length sorted Nat.== length xs
     && eqListInt sorted (sort sorted)
     && isSorted sorted;

prop-zip : List Int -> List Int -> Bool;
prop-zip xs ys :=
  let
    zs : List (Int × Int) := zip xs ys;
    expectedLen : Nat := Nat.min (length xs) (length ys);
  in length zs Nat.== expectedLen
    && eqListInt (take expectedLen xs) (map fst zs)
    && eqListInt (take expectedLen ys) (map snd zs);

prop-zipWith :
  (Int -> Int -> Int) -> List Int -> List Int -> Bool;
prop-zipWith f xs ys :=
  let
    zs : List Int := zipWith f xs ys;
    zsFlip : List Int := zipWith (flip f) ys xs;
    expectedLen : Nat := Nat.min (length xs) (length ys);
  in length zs Nat.== expectedLen
    && eqListInt zs zsFlip
    && eqListInt
      (map
        λ {
          | x := f x x
        }
        xs)
      (zipWith f xs xs);

prop-snoc : List Int -> Int -> Bool;
prop-snoc xs x :=
  let
    snoc-x : List Int := snoc xs x;
  in eqListInt snoc-x (reverse (x :: reverse xs));

prop-drop : Nat -> List Int -> Bool;
prop-drop n xs :=
  let
    drop-n : List Int;
    drop-n := drop n xs;
  in
    length drop-n Nat.<= length xs
    && eqListInt (drop n (drop n xs)) (drop (2 Nat.* n) xs);

sortTest : String -> (List Int -> List Int) -> QC.Test;
sortTest sortName sort :=
  QC.mkTest
    (QC.testableFunction QC.argumentListInt QC.testableBool)
    ("sort properties: " ++str sortName)
    (prop-sort sort);

dropTest : QC.Test;
dropTest :=
  QC.mkTest
    (QC.testableFunction
      QC.argumentNat
      (QC.testableFunction
        QC.argumentListInt QC.testableBool))
    "drop properties"
    prop-drop;

snocTest : QC.Test;
snocTest :=
  QC.mkTest
    (QC.testableFunction
      QC.argumentListInt
      (QC.testableFunction QC.argumentInt QC.testableBool))
    "snoc properties"
    prop-snoc;

zipTest : QC.Test;
zipTest :=
  QC.mkTest
    QC.testableListIntListInt
    "zip properties"
    prop-zip;

zipWithTest : QC.Test;
zipWithTest :=
  QC.mkTest
    QC.testableHofIntIntListIntListInt
    "zipWith properties"
    prop-zipWith;

equalCompareToEqTest : QC.Test;
equalCompareToEqTest :=
  QC.mkTest
    (QC.testableFunction QC.argumentNat QC.testableBool)
    "equal Nats compare to EQ"
    prop-equal-compare-to-eq;

gcdNoCoprimeTest : QC.Test;
gcdNoCoprimeTest :=
  QC.mkTest
    QC.testableBinaryInt
    "no integers are coprime"
    prop-gcd-bad;

partitionTest : QC.Test;
partitionTest :=
  QC.mkTest
    QC.testableListIntHofIntBool
    "partition: recombination of the output equals the input"
    prop-partition;

testDistributive : QC.Test;
testDistributive :=
  QC.mkTest
    QC.testableIntIntHofIntInt
    "all functions are distributive over +"
    prop-distributive;

reverseLengthTest : QC.Test;
reverseLengthTest :=
  QC.mkTest
    QC.testableListInt
    "reverse preserves length"
    prop-reverseDoesNotChangeLength;

reverseReverseIdTest : QC.Test;
reverseReverseIdTest :=
  QC.mkTest
    QC.testableListInt
    "reverse of reverse is identity"
    prop-reverseReverseIsIdentity;

splitAtRecombineTest : QC.Test;
splitAtRecombineTest :=
  QC.mkTest
    QC.testableNatListInt
    "splitAt: recombination of the output is equal to the input list"
    prop-splitAtRecombine;

mergeSumLengthsTest : QC.Test;
mergeSumLengthsTest :=
  QC.mkTest
    QC.testableListIntListInt
    "merge: sum of the lengths of input lists is equal to the length of output list"
    prop-mergeSumLengths;

tailLengthOneLessTest : QC.Test;
tailLengthOneLessTest :=
  QC.mkTest
    QC.testableListInt
    "tail: length of output is one less than input unless empty"
    prop-tailLengthOneLess;

main : IO;
main :=
  readLn
    \ {
      | seed :=
        QC.runTestsIO
          100
          (stringToNat seed)
          (partitionTest
            :: reverseLengthTest
            :: reverseReverseIdTest
            :: splitAtRecombineTest
            :: mergeSumLengthsTest
            :: tailLengthOneLessTest
            :: equalCompareToEqTest
            :: zipTest
            :: zipWithTest
            :: snocTest
            :: dropTest
            :: (sortTest "mergeSort" (mergeSort compare))
            :: (sortTest "quickSort" (quickSort compare))
            :: nil)
    };
