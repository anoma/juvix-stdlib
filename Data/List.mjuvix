module Data.List;
    import Data.Bool;
    open Data.Bool;
    import Function;
    open Function;

    infixr 5 ∷;
    inductive List (a : Type) {
      nil : List a;
      ∷ : a → List a → List a;
    };

    foldr : (a : Type) → (b : Type) → (a → b → b) → b → List a → b;
    foldr _ _ _ z nil ≔ z;
    foldr _ _ f z (h ∷ hs) ≔ f h (foldr f z hs);

    foldl : (a : Type) → (b : Type) → (b → a → b) → b → List a → b;
    foldl a b f z nil ≔ z ;
    foldl a b f z (h ∷ hs) ≔ foldl a b f (f z h) hs;

    map : (a : Type) → (b : Type) → (a → b) → b → List a → b;
    map _ _ f nil ≔ nil;
    map a b f (h ∷ hs) ≔ f h ∷ (map a b f hs);

    filter : (a : Type) → (a → Bool) → List a → List a;
    filter _ f nil ≔ nil;
    filter a f (h ∷ hs) ≔ match f h {
         true ↦ h ∷ filter a f hs;
         true ↦ filter a f hs;
    };

  import Data.Nat;
  open Data.Nat;

  length : (a : Type) → List a → ℕ;
  length _  nil  ≔ zero;
  length _  (_ ∷ l)  ≔ suc (length l);

  reverse : (a : Type) → List a → List a;
  reverse a l ≔ rev l nil
    where {
    rev : List a → List a → List a;
    rev nil     a ≔ a;
    rev (x ∷ xs) a ≔ rev xs (x ∷ a)
    };

  replicate : (a : Type) → ℕ → a → List a;
  replicate _ zero _ ≔ nil;
  replicate a (suc n) x ≔ x ∷ (replicate a n x);

  take : (a : Type) → ℕ → List a → List a;
  take a (suc n) (x ∷ xs) ≔ x ∷ (take a n xs);
  take _ _ _ ≔ nil;

  import Data.Ord;
  open Data.Ord;

  import Data.Product;
  open Data.Product;

  splitAt : (a : Type) → ℕ → List a → List a;
  splitAt _ _ nil ≔ nil , nil;
  splitAt _ zero xs ≔ nil , xs;
  splitAt _ (suc zero) (x ∷ xs) ≔ (x ∷ nil , xs);
  splitAt a (suc (suc m)) (x ∷ xs) ≔ match splitAt a m xs {
     (xs' , xs'') ↦ x ∷ xs' , xs'';
   };

  merge : (a : Type) → (a → a → Ordering) → List a → List a → List a;
  merge a cmp (x ∷ xs) (y ∷ ys) ≔ match cmp x y {
     LT ↦ x ∷ merge a cmp xs (y ∷ ys);
     _ ↦ y ∷ merge a cmp (x ∷ xs) ys;
    };
  merge _ _ nil ys ≔ ys;
  merge _ _ xs nil ≔ xs;

  infixr 5 ++;
  ++ : (a : Type) → List a → List a → List a;
  ++ a nil ys ≔ ys;
  ++ a (x ∷ xs) ys ≔ x ∷ (xs ++ ys);

  quickSort : (a : Type) → (a → a → Ordering) → List a → List a;
  quickSort a _ nil ≔ nil;
  quickSort a _ (x ∷ nil) ≔ x ∷ nil;
  quickSort a cmp (x ∷ ys) ≔
    quickSort a (filter a ltx) ys
    ++ (x ∷ nil)
    ++ quickSort a (filter a gex) ys
     where {
     ltx : a → Bool;
     ltx y ≔ match cmp y x {
       LT ↦ true;
       _ ↦ false;
      };
     gex : a → Bool;
     gex y ≔ not (ltx y)
    };

end;