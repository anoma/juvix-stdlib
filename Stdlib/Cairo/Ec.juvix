--- Functions for various actions on the STARK curve:
--- y^2 = x^3 + alpha * x + beta
--- where alpha = 1 and beta = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89.
--- The point at infinity is represented as (0, 0).
--- Implementation largely follows:
--- https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/cairo/common/ec.cairo
module Stdlib.Cairo.Ec;

import Stdlib.Data.Field open;
import Stdlib.Data.Bool open;

module StarkCurve;
  ALPHA : Field := 1;

  BETA : Field :=
    3141592653589793238462643383279502884197169399375105820974944592307816406665;

  ORDER : Field :=
    3618502788666131213697322783095070105526743751716087489154079457884512865583;

  GEN_X : Field :=
    874739451078007766457464989774322083649278607533249481151382481072868806602;

  GEN_Y : Field :=
    152666792071518830868575557812948353041420400780739481342941381225525861407;
end;

builtin ec_point
type Point :=
  mkPoint {
    x : Field;
    y : Field
  };

module Internal;
  builtin ec_op
  axiom ecOp : Point -> Field -> Point -> Point;
end;

--- Checks if an EC point is on the STARK curve.
isOnCurve : Point -> Bool
  | (mkPoint x y) :=
    if
      (y == 0)
      (x == 0)
      (y * y == (x * x + StarkCurve.ALPHA) * x + StarkCurve.BETA);

--- Doubles a point (computes p + p) on the elliptic curve.
--- Assumes p is a valid point on the curve.
double : Point -> Point
  | p@(mkPoint x y) :=
    if
      (y == 0)
      p
      (let
        slope := (3 * x * x + StarkCurve.ALPHA) / (2 * y);
        r_x := slope * slope - x - x;
        r_y := slope * (x - r_x) - y;
      in mkPoint (x := r_x; y := r_y));

--- Adds two valid points on the EC.
add : Point -> Point -> Point
  | p@(mkPoint x1 y1) q@(mkPoint x2 y2) :=
    if
      (y1 == 0)
      q
      (if
        (y2 == 0)
        p
        (if
          (x1 == x2)
          (if (y1 == y2) (double p) (mkPoint 0 0))
          (let
            slope := (y1 - y2) / (x1 - x2);
            r_x := slope * slope - x1 - x2;
            r_y := slope * (x1 - r_x) - y1;
          in mkPoint r_x r_y)));

--- Subtracts a point from another on the EC.
sub (p q : Point) : Point := add p q@Point{y := 0 - y};

--- Computes p + m * q on the elliptic curve.
--- Because the EC operation builtin cannot handle inputs where additions of points with the same x
--- coordinate arise during the computation, this function adds and subtracts a nondeterministic
--- point s to the computation, so that regardless of input, the probability that such additions
--- arise will become negligibly small.
--- The precise computation is therefore:
--- ((p + s) + m * q) - s
--- so that the inputs to the builtin itself are (p + s), m, and q.
---
--- Arguments:
--- p - an EC point.
--- m - the multiplication coefficient of q (a field element).
--- q - an EC point.
---
--- Returns:
--- p + m * q.
---
--- Assumptions:
--- p and q are valid points on the curve.
addMul (p : Point) (m : Field) (q : Point) : Point :=
  if
    (Point.y q == 0)
    p
    (let
      s : Point := mkPoint 0 0;
      -- TODO: make s random
      r : Point := Internal.ecOp (add p s) m q;
    in sub r s);

--- Computes m * p on the elliptic curve.
mul (m : Field) (p : Point) : Point :=
  addMul (mkPoint 0 0) m p;
