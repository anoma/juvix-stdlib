module Stdlib.Data.Maybe;

import Stdlib.Data.Maybe.Base open public;

import Stdlib.Trait.Eq open;
import Stdlib.Trait.Ord open;
import Stdlib.Trait.Show open;

import Stdlib.Data.Bool.Base open;
import Stdlib.Data.String.Base open;
import Stdlib.Data.Functor open;
import Stdlib.Data.Applicative open;
import Stdlib.Data.Monad open;
import Stdlib.Function open;

instance
eqMaybeI {A} {{Eq A}} : Eq (Maybe A) :=
  mkEq
    λ {
      | nothing nothing := true
      | (just a1) (just a2) := Eq.eq a1 a2
      | _ _ := false
    };

instance
showMaybeI {A} {{Show A}} : Show (Maybe A) :=
  mkShow
    λ {
      | nothing := "nothing"
      | (just a) := "just " ++str Show.show a
    };

instance
ordMaybeI {A} {{Ord A}} : Ord (Maybe A) :=
  mkOrd
    λ {
      | nothing nothing := EQ
      | (just a1) (just a2) := Ord.cmp a1 a2
      | nothing (just _) := LT
      | (just _) nothing := GT
    };

instance
Functor-Maybe : Functor Maybe :=
  mkFunctor@{
    map {A B} (f : A -> B) : Maybe A -> Maybe B
      | nothing := nothing
      | (just a) := just (f a)
  };

instance
Applicative-Maybe : Applicative Maybe :=
  mkApplicative@{
    functor := Functor-Maybe;
    pure {A} (a : A) : Maybe A := just a;
    apply {A B} : Maybe (A -> B) -> Maybe A -> Maybe B
      | (just f) := map f
      | nothing := const nothing
  };

instance
Monad-Maybe : Monad Maybe :=
  mkMonad@{
    applicative := Applicative-Maybe;
    bind {A B} (ma : Maybe A) (f : A -> Maybe B) : Maybe B :=
      case ma of {
        | just a := f a
        | nothing := nothing
      }
  };
