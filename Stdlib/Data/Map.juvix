module Stdlib.Data.Map;

import Stdlib.Data.Pair open;
import Stdlib.Data.Maybe open;
import Stdlib.Data.List open;
import Stdlib.Data.Nat open;

import Stdlib.Trait.Functor open;
import Stdlib.Trait.Foldable open;
import Stdlib.Trait.Ord open;

import Stdlib.Function open;

import Stdlib.Data.Set as Set;
open Set using {Set};

import Stdlib.Data.Set.AVL as AVL;
open AVL using {AVLTree};

import Stdlib.Data.BinaryTree as Tree;

type Binding Key Value :=
  mkBinding@{
    key : Key;
    value : Value
  };

key {Key Value} (binding : Binding Key Value) : Key := Binding.key binding;

value {Key Value} (binding : Binding Key Value) : Value := Binding.value binding;

toPair {Key Value} (binding : Binding Key Value) : Pair Key Value := key binding, value binding;

instance
bindingKeyOrdering {Key Value} {{Ord Key}} : Ord (Binding Key Value) :=
  mkOrd@{
    {-# inline: true #-}
    cmp (b1 b2 : Binding Key Value) : Ordering := Ord.cmp (key b1) (key b2)
  };

type Map Key Value := mkMap (AVLTree (Binding Key Value));

empty {Key Value} : Map Key Value := mkMap AVL.empty;

{-# specialize: [1, f] #-}
insertWith
  {Key Value}
  {{Ord Key}}
  (fun : Value -> Value -> Value)
  (key : Key)
  (value : Value)
  (map : Map Key Value)
  : Map Key Value :=
  case map of
    mkMap tree :=
      let
        fun' (binding1 binding2 : Binding Key Value) : Binding Key Value :=
          case binding1, binding2 of mkBinding a b1, mkBinding _ b2 := mkBinding a (fun b1 b2);
        binding := mkBinding key value;
      in mkMap (Set.insertWith fun' binding tree);

{-# inline: true #-}
insert {Key Value : Type} {{Ord Key}} : Key -> Value -> Map Key Value -> Map Key Value :=
  insertWith λ {old new := new};

{-# specialize: [1] #-}
lookup {Key Value} {{Ord Key}} (lookupKey : Key) (container : Map Key Value) : Maybe Value :=
  case container of mkMap s := map value (Set.lookupWith key lookupKey s);

{-# specialize: [1, f] #-}
fromListWith {Key Value} {{Ord Key}} (f : Value -> Value -> Value) (xs : List (Pair Key Value)) : Map Key Value :=
  for (acc := empty) (k, v in xs)
    insertWith f k v acc;

{-# inline: true #-}
fromList {Key Value} {{Ord Key}} : List (Pair Key Value) -> Map Key Value := fromListWith λ {old new := new};

toList {Key Value} (container : Map Key Value) : List (Pair Key Value) :=
  case container of mkMap s := map (x in Set.toList s) toPair x;

{-# inline: true #-}
size {Key Value} (container : Map Key Value) : Nat := case container of mkMap s := Set.size s;

{-# inline: true #-}
delete {Key Value} {{Ord Key}} (deleteKey : Key) (container : Map Key Value) : Map Key Value :=
  case container of mkMap s := mkMap (Set.deleteWith key deleteKey s);

keys {Key Value} (container : Map Key Value) : List Key :=
  case container of mkMap s := map (x in Set.toList s) {key x};

values {Key Value} (container : Map Key Value) : List Value :=
  case container of mkMap s := map (x in Set.toList s) {value x};

keySet {Key Value} {{Ord Key}} (container : Map Key Value) : Set Key :=
  case container of mkMap s := Set.map (x in s) {key x};

valueSet {Key Value} {{Ord Value}} (container : Map Key Value) : Set Value :=
  case container of mkMap s := Set.map (x in s) {value x};

mapValues {Key Value1 Value2} (f : Value1 -> Value2) (container : Map Key Value1) : Map Key Value2 :=
  case container of mkMap s := mkMap (Set.Internal.unsafeMap \ {(mkBinding k v) := mkBinding k (f v)} s);

instance
eqMapI {A B} {{Eq A}} {{Eq B}} : Eq (Map A B) := mkEq (Eq.eq on toList);

instance
ordMapI {A B} {{Ord A}} {{Ord B}} : Ord (Map A B) := mkOrd (Ord.cmp on toList);
