--- AVL trees are a type of self-balancing binary search tree, where the heights
--- of the left and right subtrees of every node differ by at most 1. This
--- ensures that the height of the tree is logarithmic in the number of nodes,
--- which guarantees efficient insertion, deletion, and search operations (all
--- are guaranteed to run in ùí™(log ùìÉ) time).
---
--- This module defines an AVL tree data type and provides functions for
--- constructing, modifying, and querying AVL trees.
module Stdlib.Data.Set.AVL;

import Stdlib.Data.Tree as Tree open using {Tree; Forest};
import Stdlib.Data.Maybe open;
import Stdlib.Data.Nat open;
import Stdlib.Data.Int open;
import Stdlib.Data.Bool open;
import Stdlib.Data.Pair open;
import Stdlib.Data.List open hiding {isMember};
import Stdlib.Data.String open;
import Stdlib.Trait.Foldable open;
import Stdlib.Function open;

--- A self-balancing binary search tree.
type AVLTree (A : Type) :=
  | --- An empty AVL tree.
    empty
  | --- A node of an AVL tree.
    node {
      element : A;
      height : Nat;
      left : AVLTree A;
      right : AVLTree A
    };

--- ùí™(1) Retrieves the height of an ;AVLTree;. The height is the distance from
--- the root to the deepest child.
height {A} (tree : AVLTree A) : Nat :=
  case tree of
    | empty := 0
    | node@{height} := height;

type BalanceFactor :=
  | --- Left children is higher.
    LeanLeft
  | --- Equal heights of children.
    LeanNone
  | --- Right children is higher.
    LeanRight;

{-# inline: true #-}
diffFactor {A} (tree : AVLTree A) : Int :=
  case tree of
    | empty := 0
    | node@{left; right} := intSubNat (height right) (height left);

--- ùí™(1). Computes the balance factor, i.e., the height of the right subtree
--- minus the height of the left subtree.
{-# inline: true #-}
balanceFactor {A} (tree : AVLTree A) : BalanceFactor :=
  let
    diff : Int := diffFactor tree;
  in if
    | 0 < diff := LeanRight
    | diff < 0 := LeanLeft
    | else := LeanNone;

--- ùí™(1). Helper function for creating a node.
mknode {A} (value : A) (left : AVLTree A) (right : AVLTree A) : AVLTree A :=
  node value (1 + max (height left) (height right)) left right;

--- ùí™(1). Left rotation.
rotateLeft {A} (tree : AVLTree A) : AVLTree A :=
  case tree of
    | node x _ a (node z _ b c) := mknode z (mknode x a b) c
    | n := n;

--- ùí™(1). Right rotation.
rotateRight {A} (tree : AVLTree A) : AVLTree A :=
  case tree of
    | node z _ (node y _ x t3) t4 := mknode y x (mknode z t3 t4)
    | n := n;

--- ùí™(1). Applies local rotations if needed.
balance {A} (tree : AVLTree A) : AVLTree A :=
  case tree of
    | empty := empty
    | node@{element; height; left; right} :=
      let
        factor : BalanceFactor := balanceFactor tree;
      in case factor of
           | LeanRight :=
             case balanceFactor right of {
               | LeanLeft := rotateLeft (mknode element left (rotateRight right))
               | _ := rotateLeft tree
             }
           | LeanLeft :=
             case balanceFactor left of {
               | LeanRight := rotateRight (mknode element (rotateLeft left) right)
               | _ := rotateRight tree
             }
           | LeanNone := tree;

--- ùí™(log ùìÉ). Lookup a member from the ;AVLTree; using a projection function.
--- Ord A, Ord K and fun must be compatible. i.e cmp_k (fun a1) (fun a2) == cmp_a a1 a2
{-# specialize: [1, 2] #-}
lookupWith {A K} {{order : Ord K}} (fun : A -> K) (elem : K) (tree : AVLTree A) : Maybe A :=
  let
    {-# specialize-by: [order, fun] #-}
    go : AVLTree A -> Maybe A
      | empty := nothing
      | node@{element; left; right} :=
        case Ord.cmp elem (fun element) of
          | LT := go left
          | GT := go right
          | EQ := just element;
  in go tree;

--- ùí™(log ùìÉ). Queries whether an element is in an ;AVLTree;.
{-# specialize: [1] #-}
lookup {A} {{Ord A}} (elem : A) (tree : AVLTree A) : Maybe A := lookupWith id elem tree;

--- ùí™(log ùìÉ). Queries whether an element is in an ;AVLTree;.
isMember {A} {{Ord A}} (elem : A) (tree : AVLTree A) : Bool := isJust (lookupWith id elem tree);

--- ùí™(log ùìÉ). Inserts an element elem into and ;AVLTree; using a function to
--- deduplicate entries.
---
--- Assumption: If a1 == a2 then fun a1 a2 == a1 == a2
--- where == comes from Ord a.
{-# specialize: [1, 2] #-}
insertWith {A} {{order : Ord A}} (fun : A -> A -> A) (elem : A) (tree : AVLTree A) : AVLTree A :=
  let
    {-# specialize-by: [order, fun] #-}
    go : AVLTree A -> AVLTree A
      | empty := mknode elem empty empty
      | node@{element; height; left; right} :=
        case Ord.cmp elem element of
          | LT := balance (mknode element (go left) right)
          | GT := balance (mknode element left (go right))
          | EQ := node (fun element elem) height left right;
  in go tree;

--- ùí™(log ùìÉ). Inserts an element into and ;AVLTree;.
insert {A} {{Ord A}} (elem : A) (tree : AVLTree A) : AVLTree A := insertWith (flip const) elem tree;

--- ùí™(log ùìÉ). Removes the minimum element from an ;AVLTree;.
{-# specialize: [1] #-}
deleteMin {A} {{Ord A}} : (tree : AVLTree A) -> Maybe (Pair A (AVLTree A))
  | empty := nothing
  | node@{element; left; right} :=
    case deleteMin left of
      | nothing := just (element, right)
      | just (element', left') := just (element', mknode element left' right);

--- ùí™(log ùìÉ). Removes an element from an ;AVLTree; based on a projected comparison value.
---
--- Assumption Ord A and Ord B are compatible: Given a1 a2, A then (fun a1 == fun a2) == (a1 == a2)
{-# specialize: [1, 2, 3] #-}
deleteWith
  {A B}
  {{orderA : Ord A}}
  {{orderB : Ord B}}
  (fun : A -> B)
  (elem : B)
  (tree : AVLTree A)
  : AVLTree A :=
  let
    {-# specialize-by: [orderA, orderB, fun] #-}
    go : AVLTree A -> AVLTree A
      | empty := empty
      | node@{element; left; right} :=
        case Ord.cmp elem (fun element) of
          | LT := balance (mknode element (go left) right)
          | GT := balance (mknode element left (go right))
          | EQ :=
            case left of
              | empty := right
              | _ :=
                case deleteMin right of
                  | nothing := left
                  | just (minRight, right') := balance (mknode minRight left right');
  in go tree;

--- ùí™(log ùìÉ). Removes an element from an ;AVLTree;.
{-# specialize: [1] #-}
delete {A} {{o : Ord A}} : A -> AVLTree A -> AVLTree A := deleteWith id;

--- ùí™(log ùìÉ). Returns the minimum element of the ;AVLTree;.
lookupMin {A} : AVLTree A -> Maybe A
  | empty := nothing
  | (node y _ empty empty) := just y
  | (node _ _ empty r) := lookupMin r
  | (node _ _ l _) := lookupMin l;

--- ùí™(log ùìÉ). Returns the maximum element of the ;AVLTree;.
lookupMax {A} : AVLTree A -> Maybe A
  | empty := nothing
  | (node y _ empty empty) := just y
  | (node _ _ l empty) := lookupMax l
  | (node _ _ _ r) := lookupMax r;

--- ùí™(ùíπ log ùìÉ). Deletes d elements from an ;AVLTree;.
{-# specialize: [1] #-}
deleteMany {A} {{Ord A}} : List A -> AVLTree A -> AVLTree A := deleteManyWith id;

--- ùí™(ùíπ log ùìÉ). Deletes d elements from an ;AVLTree; based on a projected comparison value.
---
--- Assumption Ord A and Ord B are compatible: Given a1 a2, A then (fun a1 == fun a2) == (a1 == a2)
{-# specialize: [1, 2] #-}
deleteManyWith {A B} {{Ord A}} {{Ord B}} (fun : A -> B) (toDelete : List B) (tree : AVLTree A) : AVLTree A :=
  for (acc := tree) (x in toDelete)
    deleteWith fun x acc;

--- ùí™(ùìÉ). Checks the ;AVLTree; height invariant. I.e. that
--- every two children do not differ on height by more than 1.
isBalanced {A} : (tree : AVLTree A) -> Bool
  | empty := true
  | tree@node@{left; right} := isBalanced left && isBalanced right && abs (diffFactor tree) <= 1;

--- ùí™(ùìÉ log ùìÉ). Create an ;AVLTree; from an unsorted ;List;.
{-# specialize: [1] #-}
fromList {A} {{Ord A}} (list : List A) : AVLTree A :=
  for (acc := empty) (x in list) {insert x acc};

--- ùí™(ùìÉ). Returns the number of elements of an ;AVLTree;.
size {A} : AVLTree A -> Nat
  | empty := 0
  | node@{left; right} := 1 + size left + size right;

-- TODO: Implement this tail-recursively with an accumulator. Then it will be O(n).
--- ùí™(n log n). Returns the elements of an ;AVLTree; in ascending order.
toList {A} : AVLTree A -> List A
  | empty := nil
  | node@{element; left; right} := toList left ++ (element :: nil) ++ toList right;

-- TODO: avoid conversion to list.
--- ùí™(n log n). Returns an ;AVLTree; containing elements that are members of both ;AVLTree;s.
intersection {A} {{Ord A}} (s1 s2 : AVLTree A) : AVLTree A :=
  toList s1 |> filter \ {x := isMember x s2} |> fromList;

-- TODO: avoid conversion to list.
--- ùí™(n log n). Returns an ;AVLTree; containing elements that are members of the first but not the second ;AVLTree;.
difference {A} {{Ord A}} (s1 s2 : AVLTree A) : AVLTree A :=
  toList s1 |> filter \ {x := not (isMember x s2)} |> fromList;

-- TODO: avoid conversion to list.
--- ùí™(n log n). Returns an ;AVLTree; containing elements that are members of either the first or second ;AVLTree;.
union {A} {{Ord A}} (s1 s2 : AVLTree A) : AVLTree A := fromList (toList s1 ++ toList s2);

--- Formats the tree in a debug friendly format.
prettyDebug {A} {{Show A}} (tree : AVLTree A) : String :=
  let
    go : AVLTree A -> String
      | empty := "_"
      | tree@node@{element; left; right} :=
        "("
          ++str go left
          ++str " h"
          ++str Show.show (diffFactor tree)
          ++str " "
          ++str Show.show element
          ++str " "
          ++str go right
          ++str ")";
  in go tree;

--- ùí™(ùìÉ).
toTree {A} : (tree : AVLTree A) -> Maybe (Tree A)
  | empty := nothing
  | node@{element; left; right} := just (Tree.node element (catMaybes (toTree left :: toTree right :: nil)));

--- Returns the textual representation of an ;AVLTree;.
pretty {A} {{Show A}} (tree : AVLTree A) : String :=
  maybe "empty" Tree.treeToString (toTree tree);

-- TODO: remove toList
instance
eqAVLTreeI {A} {{Eq A}} : Eq (AVLTree A) := mkEq ((==) on toList);

-- TODO: remove toList
instance
ordAVLTreeI {A} {{Ord A}} : Ord (AVLTree A) := mkOrd (Ord.cmp on toList);

-- TODO: remove toList
{-# specialize: true, inline: case #-}
instance
polymorphicFoldableAVLTreeI : Polymorphic.Foldable AVLTree :=
  Polymorphic.mkFoldable@{
    for {A B} (f : B -> A -> B) (acc : B) (tree : AVLTree A) : B :=
      Polymorphic.Foldable.for f acc (toList tree);
    rfor {A B} (f : B ‚Üí A ‚Üí B) (acc : B) (tree : AVLTree A) : B :=
      Polymorphic.Foldable.rfor f acc (toList tree)
  };

{-# specialize: true, inline: true #-}
instance
foldableVLTreeI {A} : Foldable (AVLTree A) A := fromPolymorphicFoldable;
