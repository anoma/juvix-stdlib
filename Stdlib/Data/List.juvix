module Stdlib.Data.List;

open import Stdlib.Data.Bool;
open import Stdlib.Function;
open import Stdlib.Data.Nat;
open import Stdlib.Data.Ord;
open import Stdlib.Data.Product;
open import Stdlib.Debug.Fail;

infixr 5 ::;
--- Inductive list.
type List (a : Type) :=
  | --- The empty list
    nil : List a
  | --- An element followed by a list
    :: : a â†’ List a â†’ List a;

--- ğ’ª(ğ“ƒ). Returns ;true; if the given
--- object is in the ;List;.
elem : {A : Type} â†’ (A â†’ A â†’ Bool) â†’ A â†’ List A â†’ Bool;
elem _ _ nil := false;
elem eq s (x :: xs) := eq s x || elem eq s xs;

--- Right-associative fold.
foldr :
  {A : Type} â†’ {B : Type} â†’ (A â†’ B â†’ B) â†’ B â†’ List A â†’ B;
foldr _ z nil := z;
foldr f z (h :: hs) := f h (foldr f z hs);

--- Left-associative and tail-recursive fold.
foldl :
  {A : Type} â†’ {B : Type} â†’ (B â†’ A â†’ B) â†’ B â†’ List A â†’ B;
foldl f z nil := z;
foldl f z (h :: hs) := foldl f (f z h) hs;

--- ğ’ª(ğ“ƒ). Maps a function over each element of a ;List;.
map : {A : Type} â†’ {B : Type} â†’ (A â†’ B) â†’ List A â†’ List B;
map f nil := nil;
map f (h :: hs) := f h :: map f hs;

--- ğ’ª(ğ“ƒ). Only keeps the elements for which the
--- given predicate returns ;true;.
filter : {A : Type} â†’ (A â†’ Bool) â†’ List A â†’ List A;
filter _ nil := nil;
filter f (h :: hs) :=
  if (f h) (h :: filter f hs) (filter f hs);

--- ğ’ª(ğ“ƒ). Returns the length of the ;List;.
length : {A : Type} â†’ List A â†’ Nat;
length nil := zero;
length (_ :: l) := suc (length l);

--- ğ’ª(ğ“ƒ). Returns the given ;List; in reverse order.
reverse : {A : Type} â†’ List A â†’ List A;
reverse := foldl (flip (::)) nil;

--- Returns a ;List; of length n where every element is the given value.
replicate : {A : Type} â†’ Nat â†’ A â†’ List A;
replicate zero _ := nil;
replicate (suc n) x := x :: replicate n x;

--- Takes the first n elements of a ;List;.
take : {A : Type} â†’ Nat â†’ List A â†’ List A;
take (suc n) (x :: xs) := x :: take n xs;
take _ _ := nil;

--- ğ’ª(ğ“ƒ). splitAt n xs returns a tuple where first element is xs
--- prefix of length n and second element is the remainder of the ;List;.
splitAt : {A : Type} â†’ Nat â†’ List A â†’ List A Ã— List A;
splitAt _ nil := nil, nil;
splitAt zero xs := nil, xs;
splitAt (suc zero) (x :: xs) := x :: nil, xs;
splitAt (suc (suc m)) (x :: xs) :=
  first ((::) x) (splitAt m xs);

--- ğ’ª(ğ“ƒ + ğ“‚). Merges two lists according the given ordering.
merge :
  {A : Type}
    â†’ (A â†’ A â†’ Ordering)
    â†’ List A
    â†’ List A
    â†’ List A;
merge cmp (x :: xs) (y :: ys) :=
  if
    (isLT (cmp x y))
    (x :: merge cmp xs (y :: ys))
    (y :: merge cmp (x :: xs) ys);
merge _ nil ys := ys;
merge _ xs nil := xs;

--- ğ’ª(ğ“ƒ). Returns a tuple for the first component has the items that
--- satisfy the predicate and the second component has the elements that don't.
partition :
  {A : Type} â†’ (A â†’ Bool) â†’ List A â†’ List A Ã— List A;
partition _ nil := nil, nil;
partition f (x :: xs) :=
  if (f x) first second ((::) x) (partition f xs);

--- Concatenates two ;List;s.
infixr 5 ++;
++ : {A : Type} â†’ List A â†’ List A â†’ List A;
++ nil ys := ys;
++ (x :: xs) ys := x :: xs ++ ys;

--- Concatenates a ;List; of ;List;s.
flatten : {A : Type} â†’ List (List A) â†’ List A;
flatten := foldl (++) nil;

--- ğ’ª(ğ“ƒ). Inserts the given element before every element in the given ;List;.
prependToAll : {A : Type} â†’ A â†’ List A â†’ List A;
prependToAll _ nil := nil;
prependToAll sep (x :: xs) :=
  sep :: x :: prependToAll sep xs;

--- ğ’ª(ğ“ƒ). Inserts the given element inbetween every two elements in the given ;List;.
intersperse : {A : Type} â†’ A â†’ List A â†’ List A;
intersperse _ nil := nil;
intersperse sep (x :: xs) := x :: prependToAll sep xs;

--- ğ’ª(1). Partial function that returns the first element of a ;List;.
head : {A : Type} â†’ List A â†’ A;
head (x :: _) := x;
head nil := fail "head: empty list";

--- ğ’ª(1). Drops the first element of a ;List;.
tail : {A : Type} â†’ List A â†’ List A;
tail (_ :: xs) := xs;
tail nil := nil;

--- ğ’ª(ğ“ƒ * ğ“‚). Partial function that transposes a ;List; of ;List;s interpreted as a matrix.
terminating
transpose : {A : Type} â†’ List (List A) â†’ List (List A);
transpose (nil :: _) := nil;
transpose xss := map head xss :: transpose (map tail xss);

--- ğ’ª(ğ“ƒ). Returns ;true; if at least on element of the ;List; satisfies the predicate.
any : {A : Type} â†’ (A â†’ Bool) â†’ List A â†’ Bool;
any f xs := foldl or false (map f xs);

--- ğ’ª(1). Returns ;true; if the ;List; is empty.
null : {A : Type} â†’ List A â†’ Bool;
null nil := true;
null _ := false;
